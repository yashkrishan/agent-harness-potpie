A. Arrow Key Behavior & Canvas Navigation

1. How should new panning shortcuts coexist with existing arrow key behavior that moves tables by 10px (via moveTables in Hotkey.elm)?
A. Replace table movement with canvas panning entirely
B. Use Shift+Arrow for canvas panning, keep Arrow keys for table movement
C. Use context-aware behavior (pan when nothing selected, move when table selected)
D. Use Alt+Arrow for table movement, Arrow keys for panning
E. Let users configure the behavior in settings
➡️ Needs input — The existing moveTables function uses {dx: ±10, dy: ±10} for grid-aligned movement. Need to decide if this behavior should be preserved or modified.

2. What is the relationship between hotkey definitions in Conf.elm and handlers in Hotkey.elm?
A. They are independent systems that don't interact
B. Conf.elm defines hotkey mappings, Hotkey.elm contains handlers that process matched keys
C. Hotkey.elm defines both mappings and handlers
D. Conf.elm handles all keyboard events directly
E. They are merged into a single module
➡️ Assumed: B — Code shows Conf.hotkeys Dict with key mappings (e.g., "move-up" → ArrowUp), while Hotkey.elm has handleHotkey function with case statements.

3. How should the zoom shortcuts handle keyboard layout variations (US vs international keyboards)?
A. Only support US keyboard layout
B. Support both '=' and '+' for zoom in to handle Shift key variations
C. Let users configure zoom keys in settings
D. Use number keys instead (1 for zoom in, 2 for zoom out)
E. Only use Ctrl+scroll for zoom
➡️ Assumed: B — Supporting both '=' and '+' (Shift+=) provides maximum compatibility across keyboard layouts.

B. Zoom Implementation Details

4. What zoom increment should keyboard shortcuts use? Current Conf.elm defines zoom: { min: 0.001, max: 5, speed: 0.001 }
A. Use existing speed value (0.001) from Conf.canvas.zoom.speed
B. 10% of current zoom level (zoom * 0.1)
C. Fixed 0.1 increment regardless of current zoom
D. Match the scroll wheel zoom behavior
E. Logarithmic scaling based on current zoom level
➡️ Assumed: B (10% increments) — Provides consistent feel at all zoom levels. At zoom=1, increment is 0.1; at zoom=2, increment is 0.2.

5. How should zoom bounds be enforced? Current Conf.canvas.zoom defines min=0.001, max=5.
A. Ignore zoom limits, allow any zoom level
B. Clamp zoom values using existing Conf.canvas.zoom.min and max
C. Show error toast when limits reached
D. Wrap around (max zoom goes to min)
E. Use different limits for keyboard vs mouse zoom
➡️ Assumed: B — Existing performZoom function already clamps values. Keyboard zoom should use same bounds for consistency.

6. How should zoom interact with the undo/redo system in Hotkey.elm?
A. Zoom changes should not be undoable
B. Each zoom step creates a history entry
C. Only undo zoom when explicitly requested
D. Group multiple rapid zoom steps into single undo action
E. Zoom uses separate undo stack
➡️ Needs input — The existing Undo/Redo messages handle layout changes. Decide if zoom should be part of layout history.

C. Canvas Panning Implementation

7. How many pixels should each Shift+Arrow key press pan the canvas? Current table movement uses 10px grid.
A. 10px (match existing Conf.canvas.grid value)
B. 50px (noticeable but controlled movement)
C. 100px (faster navigation for large schemas)
D. Percentage of viewport (10% of visible area)
E. Configurable via Conf.elm
➡️ Needs input — Panning needs to feel different from table movement. Consider that users navigate schemas with 100+ tables.

8. Should panning be smooth/animated or instant?
A. Instant position change (matches current table movement)
B. Smooth CSS transition animation
C. Eased animation using requestAnimationFrame
D. User preference in settings
E. Smooth only for keyboard, instant for drag
➡️ Assumed: A — Matches existing pattern where TableMove is instant. Keeps implementation simple and performant.

9. How should panning work when tables are selected?
A. Pan the canvas, tables stay selected
B. Deselect tables before panning
C. Move selected tables instead of panning
D. Pan canvas and move selected tables together
E. Show warning that tables are selected
➡️ Assumed: A — Shift+Arrow should always pan. Arrow keys (without Shift) handle table movement via existing moveTables.

D. Tool Switching Implementation

10. What keyboard shortcuts should be used for tool switching given existing hotkeys in Conf.elm?
A. Number keys (1 for select, 2 for drag) - simple but may conflict
B. 'v' for select, 'h' for hand/drag (matches Figma)
C. Space bar to toggle between tools (temporary drag while held)
D. 'd' for drag - but note 'd' is currently unused in hotkeys
E. Tab to cycle through tools
➡️ Assumed: B — 'v' is industry standard. 'h' for hand tool. Note: existing 'h' is "hide" so may need Alt+h for hand.

11. Should tool switching be toggle or hold-to-activate?
A. Toggle only - press to switch, stays until pressed again
B. Hold for temporary tool, release to return
C. Both - tap to toggle, hold for temporary
D. Context menu selection only
E. Double-tap to toggle
➡️ Needs input — Affects workflow significantly. Designers often prefer hold-to-drag, developers prefer toggle.

E. New Hotkey Entries in Conf.elm

12. What format should new hotkeys follow in the Conf.hotkeys Dict?
A. Follow existing naming: "zoom-in", "zoom-out", "pan-up", etc.
B. Use grouped naming: "canvas-zoom-in", "canvas-pan-up", etc.
C. Use shorthand: "z+", "z-", "p↑", etc.
D. Match DOM event key names exactly
E. Use numeric codes instead of names
➡️ Assumed: A — Matches existing patterns like "move-up", "reset-zoom", "fit-to-screen" in Conf.elm.

13. Should new hotkeys support the existing target filtering? (e.g., search-up targets input#app-nav-search)
A. No targeting needed for canvas operations
B. Target the #erd canvas element specifically
C. Allow targeting but make it optional
D. Use same targeting as table operations
E. New targeting system for canvas
➡️ Assumed: A — Canvas operations are global and don't need element targeting unlike search which targets specific input.

F. Integration with Existing Zoom

14. How should new zoom shortcuts interact with existing Ctrl+0 (reset-zoom) and Ctrl+Alt+0 (fit-to-screen)?
A. Replace them with simpler = and - shortcuts
B. Keep existing shortcuts, add = and - as alternatives
C. Remove reset-zoom, keep only fit-to-screen
D. Consolidate all zoom controls under a single modifier
E. Make = and - primary, move Ctrl+0 to secondary
➡️ Assumed: B — Preserves backward compatibility. Power users keep muscle memory while new users discover simpler shortcuts.

15. Should '0' key reset zoom to 100% like in design tools?
A. Yes, standalone '0' resets to zoom=1
B. Keep Ctrl+0 only, don't add standalone '0'
C. Make '0' context-aware (reset if zoomed, fit if at 100%)
D. '0' fits content, Ctrl+0 resets to 100%
E. Remove all reset functionality
➡️ Needs input — Conflicts with potential future numeric shortcuts. Need to decide priority.

G. Help Modal Updates

16. The Help modal is triggered by "?" hotkey. How should new shortcuts be documented?
A. Add new "Navigation" section in Help modal
B. Append to existing keyboard shortcuts list
C. Create separate "Canvas Controls" help tab
D. Show tooltips on hover instead of help modal
E. Auto-generate documentation from Conf.hotkeys Dict
➡️ Needs input — Help modal structure affects discoverability. Consider whether to group by feature or by key type.

17. Should tooltips on zoom buttons show keyboard shortcuts?
A. No, keep tooltips action-only
B. Yes, format as "Zoom in (=)"
C. Show shortcut on extended hover only
D. Show shortcuts in status bar instead
E. Make it a user preference
➡️ Assumed: B — Maximum discoverability without cluttering UI. Users learn shortcuts naturally.

H. Testing Strategy

18. What testing approach for the new handlers in Hotkey.elm?
A. Manual browser testing only
B. Elm unit tests for handleHotkey cases + browser testing
C. Property-based tests with elm-test
D. Integration tests with elm-program-test
E. E2E tests with Playwright/Cypress
➡️ Assumed: B — Follows existing pattern. handleHotkey is a pure function that returns (Model, Extra Msg), testable with elm-test.

19. How should cross-browser keyboard handling be tested?
A. Test only in Chrome
B. Manual testing in Chrome, Firefox, Safari
C. Automated cross-browser tests
D. Document known issues per browser
E. Use polyfill library to normalize
➡️ Assumed: B — Keyboard events vary across browsers. Manual verification needed for modifier keys especially.

I. Message Types for New Actions

20. What Msg types are needed? Current pattern uses specific messages like Zoom, FitToScreen, TableMove.
A. Reuse existing Zoom msg with delta parameter
B. Add new ZoomIn, ZoomOut, PanCanvas Delta messages
C. Single CanvasAction msg with action type parameter
D. Extend TableMove to handle canvas panning
E. Use port commands directly without Elm messages
➡️ Needs input — Architecture decision affects code organization. Consider whether canvas panning is conceptually similar to table movement.

21. Should panning create a new Msg or modify existing Move messages?
A. New PanCanvas Delta Msg for clarity
B. Reuse Move with special delta values
C. Add isPan flag to TableMove
D. Handle in TypeScript before Elm
E. Direct DOM manipulation
➡️ Assumed: A — Separation of concerns. Canvas panning is fundamentally different from table movement in intent.

J. Error Handling & Edge Cases

22. What should happen when user zooms at minimum (0.001) or maximum (5)?
A. Silently ignore the command
B. Show toast: "Cannot zoom further"
C. Visual bounce/shake feedback
D. Play subtle audio cue
E. Temporarily disable zoom shortcut
➡️ Assumed: A — Silent ignore matches existing button behavior. Avoid disruptive feedback for common action.

23. How should rapid key presses be handled (holding down = key)?
A. Execute zoom on each keydown event
B. Debounce to limit zoom rate
C. Accelerate zoom the longer key is held
D. Only respond to initial press
E. Queue and batch zoom operations
➡️ Assumed: A — Native key repeat handling is sufficient. Let OS control repeat rate.

K. Implementation Priority

24. In what order should features be implemented?
A. All features in single PR
B. Phase 1: Zoom (=/-/0), Phase 2: Pan (Shift+Arrows), Phase 3: Tools & Help
C. Start with Help modal updates, then add shortcuts incrementally
D. Implement panning first as it's most requested
E. Random order based on complexity
➡️ Assumed: B — Zoom builds on existing performZoom infrastructure. Pan requires new Delta handling. Tools need UI changes.

L. Documentation & Communication

25. How should the new shortcuts be communicated to existing users?
A. Release notes only
B. In-app notification/banner on first use after update
C. Updated Help modal is sufficient
D. Blog post announcement
E. All of the above
➡️ Needs input — Depends on release process and user communication channels. Consider user disruption vs discoverability.

26. Should keyboard shortcuts be documented in README.md?
A. Yes, add comprehensive shortcuts section
B. No, keep README focused on setup/installation
C. Link to in-app Help from README
D. Separate SHORTCUTS.md file
E. Only document in code comments
➡️ Assumed: C — README stays focused. Link to docs or in-app Help for detailed reference.

M. Accessibility Considerations

27. How should screen reader users be informed of shortcut availability?
A. ARIA labels on buttons mentioning shortcuts
B. Separate accessibility documentation
C. Screen reader announces shortcuts on hover
D. No special handling needed
E. Keyboard shortcuts section in Help modal is sufficient
➡️ Assumed: A — ARIA labels like "Zoom in, keyboard shortcut equals" provide inline accessibility.

28. Should there be a way to disable keyboard shortcuts for users who need them?
A. No, shortcuts are always active
B. Global setting to disable all shortcuts
C. Per-shortcut customization
D. Focus mode that disables shortcuts
E. Conflicts with browser/OS shortcuts handled automatically
➡️ Assumed: A — Shortcuts only trigger when canvas is focused. Text inputs already handled via onInput flag.
