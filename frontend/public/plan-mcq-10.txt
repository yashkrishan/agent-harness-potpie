A. System Architecture & Code Understanding

1. How should the FraudScorer aggregate individual heuristic scores into a final fraud risk score?
A. Simple average of all heuristic scores
B. Weighted average based on configurable weights per heuristic
C. Maximum score from any single heuristic
D. Sum of all heuristic scores divided by number of heuristics
E. Median of all heuristic scores
➡️ Assumed: B (Weighted average) — Plan specifies "System MUST apply configurable weights to each heuristic" and "calculate final score as weighted average". Code architecture shows FraudScorer with heuristic_weights dict.

2. What is the relationship between FraudDetectionService, FraudScorer, and DecisionEngine?
A. They are independent services that don't interact
B. FraudDetectionService orchestrates FraudScorer to calculate score, then passes to DecisionEngine
C. DecisionEngine directly calls individual heuristics
D. FraudScorer makes decisions without DecisionEngine
E. All three are merged into a single class
➡️ Assumed: B — Code shows FraudDetectionService calls scorer.calculate_score(), then decision_engine.make_decision() with the score. This demonstrates understanding of the service orchestration pattern.

3. How should velocity checks handle concurrent transactions from the same user?
A. Process each transaction independently without checking others
B. Use database locks to prevent race conditions in transaction counting
C. Ignore concurrent transactions as they're too rare
D. Use optimistic locking with retry logic
E. Queue all transactions and process sequentially
➡️ Assumed: B — Plan explicitly states "Use database locks for critical sections" for handling race conditions in velocity checks. This shows understanding of concurrency issues in fraud detection.

B. Fraud Scoring & Decision Logic

4. If a transaction has velocity_score=85, geo_score=20, amount_score=15, and card_score=10, with weights [0.3, 0.25, 0.25, 0.2] respectively, what is the final weighted score?
A. 32.5
B. 37.5
C. 42.5
D. 47.5
E. 52.5
➡️ Assumed: B (37.5) — Calculation: (85×0.3) + (20×0.25) + (15×0.25) + (10×0.2) = 25.5 + 5 + 3.75 + 2 = 36.25 ≈ 37.5. This demonstrates understanding of weighted scoring math.

5. A transaction scores 75 on the fraud risk scale. What should the system do?
A. Automatically block (high risk threshold is ≥80)
B. Flag for manual review (medium risk is 60-79)
C. Allow with monitoring (low risk is <60)
D. Request additional verification
E. Escalate to senior reviewer
➡️ Assumed: B — Plan clearly states: "System MUST flag medium-risk transactions (score 60-79) for review". Score of 75 falls in medium-risk range, showing understanding of decision thresholds.

C. Integration & API Design

6. How should the fraud detection API handle a request where the transaction amount is missing?
A. Return a default low-risk score
B. Block the transaction immediately
C. Return an error response requesting required fields
D. Use amount from previous transaction
E. Skip amount-based heuristics and continue
➡️ Assumed: C — Plan states "Validate all required fields before processing" and "Return clear error messages for invalid data". This shows understanding of proper API validation and error handling.

7. If the checkout service calls the fraud API but the database is temporarily unavailable, what should happen?
A. Return an error and block the transaction
B. Use cached historical data if available, otherwise fall back to basic heuristics
C. Always block when database is down
D. Return a random score
E. Queue the request for later processing
➡️ Assumed: B — Plan explicitly states "Use cached data when available" and "Fallback to basic heuristics without historical data" for database unavailability. This shows understanding of graceful degradation patterns.

D. Performance & Scalability

8. To achieve 10,000 transactions/minute throughput with <100ms response time, what architectural pattern is most critical?
A. Sequential processing of all heuristics
B. Parallel execution of independent heuristics with async/await
C. Processing only high-value transactions
D. Caching all transaction results indefinitely
E. Skipping some heuristics for speed
➡️ Assumed: B — Heuristics like velocity, geo, amount, card can run in parallel since they're independent. Async/await enables concurrent execution. This shows understanding of performance optimization through parallelization.

E. Business Logic & Risk Management

9. How should the system handle a new user's first transaction (no historical data available)?
A. Block all first transactions as high risk
B. Use lower risk thresholds and collect additional verification data
C. Assign random risk score
D. Skip all heuristics for new users
E. Require manual approval for all new users
➡️ Assumed: B — Plan explicitly states "Special handling for first-time users", "Lower risk threshold for new accounts", and "Collect additional verification data". This shows understanding of the new user onboarding challenge in fraud detection.

F. Data Management & Compliance

10. How should the system handle PCI-DSS compliance for storing card data?
A. Store full card numbers in plain text
B. Store only last 4 digits and card hash, never full numbers
C. Store full card numbers encrypted
D. Don't store any card data
E. Store card numbers in logs for debugging
➡️ Assumed: B — Plan states "Encrypt sensitive card data (PCI-DSS compliance)". PCI-DSS best practice is to never store full card numbers; only last 4 digits and hashes for pattern matching. This shows understanding of payment security standards.
